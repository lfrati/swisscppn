function minit() {
  return (Math.random() * 2 - 1) * 1.5;
}

function binit() {
  return Math.random();
}

function mat4init() {
  return `mat4(${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()},${minit()})`;
}

function vec4init() {
  return `vec4(${binit()},${binit()},${binit()},${binit()})`;
}

function netinit() {
  return `Net(${mat4init()}, ${mat4init()}, ${mat4init()}, ${mat4init()}, ${mat4init()}, ${vec4init()}, ${vec4init()},  ${vec4init()}, ${vec4init()})`;
}

function instantiate_params(params) {
  let init = "Net(";
  for (let i in params) {
    p = params[i];
    if (i > 0) {
      init += ", ";
    }
    if (p[0] == "w") init += `${mat4init()}`;
    else init += `${vec4init()}`;
  }
  init += ")\n";
  return init;
}

function gen_structure(params) {
  let net = "struct Net{\n";
  for (let p of params) {
    if (p[0] == "w") net += `  mat4 ${p};\n`;
    else net += `  vec4 ${p};\n`;
  }
  net += "};\n";
  return net;
}

function gen_lerp(params) {
  let lerp_fun = `mat4 lerp(mat4 w1, mat4 w2, float t){return w1 + (w2 - w1)*t;}\nvec4 lerp(vec4 w1, vec4 w2, float t){return w1 + (w2 - w1)*t;}\n`;
  lerp_fun += "Net lerp(in Net n1, in Net n2, in float t){\n  Net n3;\n";
  for (let p of params) {
    lerp_fun += `  n3.${p} = lerp(n1.${p}, n2.${p}, t);\n`;
  }
  lerp_fun += "  return n3;\n}\n";
  return lerp_fun;
}

/*
  TODO: 
  generated by parse:

  vec4 forward(in vec4 x0_0, in Net net){
    // par : 1 -> 2 -> 1
    vec4 x1_0_0 = (x0_0 * net.w0_0_0);
    vec4 x1_0_1 = (x0_0 * net.w0_0_1);
    vec4 x1_0 = relu_norm(x1_0_0 + x1_0_1 + net.b0_0);

    // par : 1 -> 2 -> 1
    vec4 x2_0_0 = (x1_0 * net.w1_0_0);
    vec4 x2_0_1 = (x1_0 * net.w1_0_1);
    vec4 x2_0 = cos(x2_0_0 + x2_0_1 + net.b1_0);

    // fc : 1 -> 1
    vec4 x3_0 = fsig(x2_0 * net.w2_0_0 + net.b2_0);

    return x3_0;
  }

  previous hardcoded version:

  vec4 f(vec4 inputs, Net n){
      vec4 h1_1 = relu_norm(inputs * n.w1_1 + n.b1_1);
      vec4 h1_2 = relu_norm(inputs * n.w1_2 + n.b1_2);
      vec4 h1 = h1_1 + h1_2 ;
      vec4 h2_1 = cos((h1 * n.w2_2)*0.5 + n.b2_2);
      vec4 h2_2 = cos((h1 * n.w2_1)*0.5 + n.b2_1);
      vec4 h2 = h2_1 + h2_2 ;
      return fsig(h2 * n.w3);
  }

  When I made the `parse` function I wanted to use par as a mean to widen layers
  but I like the older version more. (i.e. non-linearity applied to each block, biases per block)
  I'm pretty sure the "parallel branches that get summed together" is a structure I've seen in some 
  paper recently. I guess it was a good idea?

  Also the `parse` one seem to be too high-frequency, maybe because the old one had *0.5 in the cos?
 */

function parse(conf) {
  /** Example conf:
   * const conf = [
   *     { type: "par", width: 2, f: "relu_norm" },
   *     { type: "par", width: 2, f: "cos" },
   *     { type: "fc", width: 1, f: "fsig" },
   * ];
   */

  /** After being fully instantiated foward will look like this:
   * vec4 forward(in vec4 x0_0, in Net net){
   *   // par : 1 -> 2 -> 1
   *   vec4 x1_0_0 = (x0_0 * net.w0_0_0);
   *   vec4 x1_0_1 = (x0_0 * net.w0_0_1);
   *   vec4 x1_0 = relu_norm(x1_0_0 + x1_0_1 + net.b0_0);
   *
   *   // par : 1 -> 2 -> 1
   *   vec4 x2_0_0 = (x1_0 * net.w1_0_0);
   *   vec4 x2_0_1 = (x1_0 * net.w1_0_1);
   *   vec4 x2_0 = cos(x2_0_0 + x2_0_1 + net.b1_0);
   *
   *   // fc : 1 -> 1
   *   vec4 x3_0 = fsig(x2_0 * net.w2_0_0 + net.b2_0);
   *
   *   return x3_0;
   * }
   */
  let forward = "vec4 forward(in vec4 x0_0, in Net net){\n";

  // Params are used to instantiate actual weights of the correct shape/range
  // Example params: ['w0_0_0', 'w0_0_1', 'b0_0', 'w1_0_0', 'w1_0_1', 'b1_0', 'w2_0_0', 'b2_0']
  let params = [];
  let inputs = 1;
  let outputs = 1;
  let n = conf.length;
  let i = 0;
  let b;

  for (let l in conf) {
    layer = conf[l];
    inputs = outputs;

    if (l == n - 1 && layer.width != 1) {
      console.log(
        `ERROR - Expected last layer to have width 1: Found ${layer.width}.`
      );
      return "";
    }

    if (layer.type == "fc") {
      outputs = layer.width;
      forward += `  // fc : ${inputs} -> ${outputs}\n`;
      for (let out = 0; out < outputs; out++) {
        l = `  vec4 x${i + 1}_${out} = ${layer.f}(`;
        for (let inp = 0; inp < inputs; inp++) {
          w = `w${i}_${inp}_${out}`;
          if (inp > 0) {
            l += " + ";
          }
          l += `x${i}_${inp} * net.${w}`;
          params.push(w);
        }
        b = `b${i}_${out}`;
        forward += `${l} + net.${b});\n`;
        params.push(b);
      }
      forward += `\n`;
      i += 1;
    } else if (layer.type == "par") {
      outputs = inputs;
      forward += `  // par : ${inputs} -> ${
        outputs * parseInt(layer.width)
      } -> ${inputs}\n`;
      for (let inp = 0; inp < inputs; inp++) {
        merge = "";
        for (let wid = 0; wid < layer.width; wid++) {
          w = `w${i}_${inp}_${wid}`;
          params.push(w);
          matmul = `x${i}_${inp} * net.${w}`;
          forward += `  vec4 x${i + 1}_${inp}_${wid} = (${matmul});\n`;
          if (wid > 0) merge += " + ";
          merge += `x${i + 1}_${inp}_${wid}`;
        }
        b = `b${i}_${inp}`;
        params.push(b);
        forward += `  vec4 x${i + 1}_${inp} = ${
          layer.f
        }(${merge} + net.${b});\n`;
      }
      forward += `\n`;
      i += 1;
    } else if (layer.type == "fun") {
      outputs = inputs;
      forward += `  // map ${layer.f} : ${inputs} -> ${outputs}\n`;
      for (let inp = 0; inp < inputs; inp++) {
        forward += `  x${i}_${inp} = ${layer.f}(x${i}_${inp});\n`;
      }
      forward += "\n";
    }
  }

  forward += `  return x${i}_0;\n}\n`;

  /** Example Net structure
   * struct Net{
   *   mat4 w0_0_0;
   *   mat4 w0_0_1;
   *   vec4 b0_0;
   *   mat4 w1_0_0;
   *   mat4 w1_0_1;
   *   vec4 b1_0;
   *   mat4 w2_0_0;
   *   vec4 b2_0;
   * };
   */
  let net_structure = gen_structure(params);

  /** Example lerp function
   * mat4 lerp(mat4 w1, mat4 w2, float t){return w1 + (w2 - w1)*t;}
   * vec4 lerp(vec4 w1, vec4 w2, float t){return w1 + (w2 - w1)*t;}
   * Net lerp(in Net n1, in Net n2, in float t){
   *   Net n3;
   *   n3.w0_0_0 = lerp(n1.w0_0_0, n2.w0_0_0, t);
   *   n3.w0_0_1 = lerp(n1.w0_0_1, n2.w0_0_1, t);
   *   n3.b0_0 = lerp(n1.b0_0, n2.b0_0, t);
   *   n3.w1_0_0 = lerp(n1.w1_0_0, n2.w1_0_0, t);
   *   n3.w1_0_1 = lerp(n1.w1_0_1, n2.w1_0_1, t);
   *   n3.b1_0 = lerp(n1.b1_0, n2.b1_0, t);
   *   n3.w2_0_0 = lerp(n1.w2_0_0, n2.w2_0_0, t);
   *   n3.b2_0 = lerp(n1.b2_0, n2.b2_0, t);
   *   return n3;
   * }
   */
  let lerp_fun = gen_lerp(params);

  // let init = make_init(params);
  // console.log("init:", init);

  let stub = `${net_structure}\n${forward}\n${lerp_fun}\n`;

  // console.log(finalize(stub, "...", "..."));

  return [params, (n1, n2) => `${stub}\nNet n1 = ${n1};\nNet n2 = ${n2};`];
}
