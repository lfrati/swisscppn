<!DOCTYPE html>
<title>Tiny SwissGL example</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="swissgl.js"></script>
<script src="utils.js"></script>
<style>
  body,
  html {
    margin: 0;
    padding: 0;
    overflow: hidden;
  }
  #c {
    width: 100vw;
    height: 100vh;
  }
</style>
<body>
  <canvas id="c"></canvas>
  <script>
    "use strict";
    const canvas = document.getElementById("c");
    const glsl = SwissGL(canvas);

    let n1, n2;

    const conf = [
      { type: "par", width: 2, f: "relu_norm" },
      { type: "par", width: 2, f: "cos" },
      { type: "fc", width: 1, f: "fsig" },
    ];

    let [params, finalize] = parse(conf);
    n1 = instantiate_params(params);
    n2 = instantiate_params(params);
    console.log(n1);
    console.log(n2);
    console.log(finalize(n1, n2));

    function initShader(params) {
      n1 = n2;
      n2 = instantiate_params(params);

      let Inc = `
    //*********************************************************
    //*********************** UTILITIES ***********************
    //*********************************************************

    #define HALF_PI 1.57079632679
    #define N 2 // number of recursive applications
    #define s 3. // controls steepness of fast-sigmoid
    // #define range 5. // xy-coords range
    #define range 16. // xy-coords range

    float ease4(float x) {return 1. - pow(1. - x, 4.);}
    float ease3(float x) {return 1. - pow(1. - x, 3.);}
    float ease2(float x) {return 1. - pow(1. - x, 2.);}
    float easeCos(float x) {return 0.5 - cos(x*PI)/2.;}
    float easeSmooth(float x) { return 3. * x * x - 2. * x * x * x;}

    vec4 relu_norm(vec4 xs){return (max(xs,0.)-0.4)/0.58;}
    vec4 leaky_relu(vec4 xs){return max(xs,0.1 * xs);}
    vec4 sig (vec4 xs){return (1.0/(1.0+exp(-2.0*xs)));}
    vec4 fsig (vec4 xs){return ((s * xs)/(s * abs(xs) + 1.)) * 0.5  + 0.5;}

    //*********************************************************
    //***********************  NETWORK  ***********************
    //*********************************************************

    ${finalize(n1, n2)}
    `;

      return Inc;
    }

    let Inc = initShader(params);
    const slowdown = 6;

    glsl.loop(({ time }) => {
      glsl.adjustCanvas();

      const texture = glsl({
        time: time / slowdown,
        Aspect: "fit",
        Inc,
        FP: `vec2 st = XY * range;
      float radius = distance(st,vec2(0.));
      vec4 inp = vec4(st.xy, cos(radius),sin(radius));
      // interpolate n1 and n2 weights
      // float t = easeCos(easeCos(time));
      float t = easeSmooth(easeSmooth(time));
      Net n3 = lerp(n1,n2,t);
      vec4 oup = forward(inp, n3);
      for(int i=0; i < N;i++){
         oup = forward(inp + oup, n3);
      }
      // Set final results as pixel values
      FOut = vec4(oup.xyz,1.0); // R,G,B,A`,
      });

      if (time > slowdown) {
        glsl.resetTime();
        Inc = initShader(params);
        console.log("reset:", time);
      }
    });
  </script>
</body>
