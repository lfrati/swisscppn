<!DOCTYPE html>
<title>Tiny SwissGL example</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="swissgl.js"></script>
<script src="utils.js"></script>
<style>
  body,
  html {
    margin: 0;
    padding: 0;
    overflow: hidden;
  }
  #c {
    width: 100vw;
    height: 100vh;
  }
</style>
<body>
  <canvas id="c"></canvas>
  <script>
    "use strict";
    const canvas = document.getElementById("c");
    const glsl = SwissGL(canvas);

    canvas.onclick = () => {
      console.log("clicked");
    };

    const conf = [
      { type: "par", width: 2, f: "relu_norm" },
      // { type: "par", width: 2, f: "leaky_relu" },
      { type: "f", f: "halve" },
      // { type: "f", f: "round" },
      // { type: "par", width: 2, f: "cos", affine: false },
      { type: "par", width: 2, f: "cos" },
      { type: "lin", f: "fsigmoid" },
    ];

    let [code, params] = parse(conf);
    console.log(code);
    console.log(params);

    let [texnet, COLUMNS] = make_init(params);
    console.log(texnet);

    function initShader(params) {
      let Inc = `
    //*********************************************************
    //*********************** UTILITIES ***********************
    //*********************************************************

    #define HALF_PI 1.57079632679
    #define N 2 // number of recursive applications
    #define s 3. // controls steepness of fast-sigmoid
    #define range 8. // xy-coords range

    vec4 halve(vec4 x){return x/vec4(2.0);}
    vec4 relu_norm(vec4 xs){return (max(xs,0.)-0.4)/0.58;}
    vec4 leaky_relu(vec4 xs){return max(xs,0.1 * xs);}
    vec4 sigmoid (vec4 xs){return (1.0/(1.0+exp(-2.0*xs)));}
    vec4 fsigmoid (vec4 xs){return ((s * xs)/(s * abs(xs) + 1.)) * 0.5  + 0.5;}
    float max4 (vec4 xs) {
      return max(max(max(xs.x,xs.y),xs.z),xs.w);
    }
    // https://blog.feedly.com/tricks-of-the-trade-logsumexp/
    vec4 softmax(in vec4 xs){float c = max4(xs); return xs - log( dot( exp(xs - c), vec4(1.0))) - c;}

    //*********************************************************
    //***********************  NETWORK  ***********************
    //*********************************************************

    ${code}

    vec4 get_vec4(int i, int j){
      return tex(ivec2(i, j));
    }

    mat4 get_mat4(int i, int j){
      return mat4(tex(ivec2(i, j+0)),
                  tex(ivec2(i, j+1)),
                  tex(ivec2(i, j+2)),
                  tex(ivec2(i, j+3))
      );
    }

    `;

      console.log(Inc);
      return Inc;
    }

    let Inc = initShader(params);
    const slowdown = 6;

    const GRID_SIZE = 5;
    const ROWS = GRID_SIZE * GRID_SIZE;

    const seed = Math.ceil(Math.random() * 1000);
    const points = glsl(
      {
        FP: `
	vec3 rnd1 = hash(I.xyx + ${seed});
	vec2 pos1 = (rnd1.xy-0.5)*2.*1.5;
	vec3 rnd2 = hash(I.yxy + ${seed});
	vec2 pos2 = (rnd2.xy-0.5)*2.*1.5;
	FOut = vec4(pos1, pos2);`,
      },
      { size: [ROWS, COLUMNS], format: "rgba32f", tag: "points" }
    );
    // glsl({ points, FP: `points(UV).xy/6.0+0.5, 0, 1` });

    console.log(points);

    // glsl.loop(({ time }) => {
    glsl.adjustCanvas();

    const texture = glsl({
      Grid: [GRID_SIZE, GRID_SIZE],
      // time: time / slowdown,
      Aspect: "fit",
      tex: points,
      Inc,
      VP: `
      // tile positioning
      vec2 p = (vec2(ID.xy)+0.5) / vec2(Grid.xy);
	    VPos.xy = 2.0*p-1.0 + XY*0.15;`,
      FP: `
      // texnet uses: 
      // - tex: sampler2D (passed to the shader)
      // - row: int (calculated below)
      int row = ID.y * ${GRID_SIZE} + ID .x;
      Net net1 = ${texnet};
      vec2 st = XY * range;
      float radius = distance(st,vec2(0.));
      vec4 inp = vec4(st.xy, cos(radius), sin(radius));
      vec4 oup = forward(inp, net1);
      for(int i=0; i < N;i++){
         oup = forward(inp + oup, net1);
      }
      // Set final results as pixel values
      FOut = vec4(oup.xyz,1.0); // R,G,B,A`,
    });
    // });
  </script>
</body>
