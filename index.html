<!DOCTYPE html>
<title>Tiny SwissGL example</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="swissgl.js"></script>
<script src="utils.js"></script>
<style>
  body,
  html {
    margin: 0;
    padding: 0;
    overflow: hidden;
  }
  #c {
    width: 100vw;
    height: 100vh;
  }
</style>
<body>
  <canvas id="c"></canvas>
  <script>
    "use strict";
    const canvas = document.getElementById("c");
    const glsl = SwissGL(canvas);

    canvas.onclick = () => {
      console.log("clicked");
    };

    let n1, n2;

    const conf = [
      { type: "par", width: 2, f: "relu_norm" },
      { type: "f", f: "halve" },
      // { type: "f", f: "round" },
      // { type: "par", width: 2, f: "cos", affine: false },
      { type: "par", width: 2, f: "cos" },
      { type: "lin", f: "fsigmoid" },
    ];

    let [code, params] = parse(conf);
    console.log(code);
    console.log(params);
    n1 = make_init(params);
    n2 = make_init(params);

    function initShader(params) {
      n1 = n2;
      n2 = make_init(params);

      let Inc = `
    //*********************************************************
    //*********************** UTILITIES ***********************
    //*********************************************************

    #define HALF_PI 1.57079632679
    #define N 2 // number of recursive applications
    #define s 3. // controls steepness of fast-sigmoid
    // #define range 5. // xy-coords range
    #define range 8. // xy-coords range

    float ease4(float x) {return 1. - pow(1. - x, 4.);}
    float ease3(float x) {return 1. - pow(1. - x, 3.);}
    float ease2(float x) {return 1. - pow(1. - x, 2.);}
    float easeCos(float x) {return 0.5 - cos(x*PI)/2.;}
    float easeSmooth(float x) { return 3. * x * x - 2. * x * x * x;}

    vec4 halve(vec4 x){return x/vec4(2.0);}
    vec4 relu_norm(vec4 xs){return (max(xs,0.)-0.4)/0.58;}
    vec4 leaky_relu(vec4 xs){return max(xs,0.1 * xs);}
    vec4 sigmoid (vec4 xs){return (1.0/(1.0+exp(-2.0*xs)));}
    vec4 fsigmoid (vec4 xs){return ((s * xs)/(s * abs(xs) + 1.)) * 0.5  + 0.5;}
    float max4 (vec4 xs) {
      return max(max(max(xs.x,xs.y),xs.z),xs.w);
    }
    // https://blog.feedly.com/tricks-of-the-trade-logsumexp/
    vec4 softmax(in vec4 xs){float c = max4(xs); return xs - log( dot( exp(xs - c), vec4(1.0))) - c;}

    //*********************************************************
    //***********************  NETWORK  ***********************
    //*********************************************************

    ${code}

    Net net1 = ${n1};
    Net net2 = ${n2};
    `;

      return Inc;
    }

    let Inc = initShader(params);
    const slowdown = 6;

    glsl.loop(({ time }) => {
      glsl.adjustCanvas();

      const texture = glsl({
        time: time / slowdown,
        Aspect: "fit",
        Inc,
        FP: `vec2 st = XY * range;
      float radius = distance(st,vec2(0.));
      vec4 inp = vec4(st.xy, cos(radius),sin(radius));
      // interpolate net1 and net2 weights
      // float t = easeCos(easeCos(time));
      float t = easeSmooth(easeSmooth(time));
      lerp(net1, net2, t);
      vec4 oup = forward(inp, net1);
      for(int i=0; i < N;i++){
         oup = forward(inp + oup, net1);
      }
      // Set final results as pixel values
      FOut = vec4(oup.xyz,1.0); // R,G,B,A`,
      });

      if (time > slowdown) {
        glsl.resetTime();
        Inc = initShader(params);
        console.log("reset:", time);
      }
    });
  </script>
</body>
